---
title: "Cluster 5 binoamial models"
author: "Camilo Posso"
date: "04/01/2022"
output: 
  html_document:
    code_folding: hide
    toc: true
editor_options: 
  chunk_output_type: inline
---

## Goal




```{r include=FALSE}
library(dplyr)
library(ggplot2)
library(kableExtra)
library(glmnet)
library(survminer)
library(survival)
library(groupdata2)


source("../../../util/synapseUtil.R")
source("../../../util/loading_data.R")
source("../../../util/mutational_analysis_helper.R")


load("../../../Misc/load.combined.data 3-09-2022.RData")
# load.combined.data()
global_data <- global.data
RNA_data <- RNA.data %>%
  dplyr::rename(LogRatio = `RNA counts`)

```



```{r}

cluster_assignments <- read.table("../Data/sample_to_cluster_assignments.txt", sep = "\t")
diff_markers_k5 <- read.table("../../../Misc/Extra NMF/whoknows/differential_markers_k5.txt", sep = "\t")

summary.syn <- "syn26642974"
summary.table <- read.table("../Data/PNNL_clinical_summary_12_08_2021_updated_OS_4patients_02_28_2022.txt") %>%
  as.data.frame()

rownames(summary.table) <- summary.table$labId
summary.table <- summary.table[rownames(meta), ]
meta$vitalStatus <- summary.table$vitalStatus
meta <- meta %>%
  mutate(vitalStatus = case_when(vitalStatus == "Dead" ~ 2,
                                 TRUE ~ 1))

cluster_samples <- cluster_assignments$Barcode.ID
global_data <- global.data %>%
  filter(Barcode.ID %in% cluster_samples)
global_data_test <- global.data %>%
  filter(!(Barcode.ID %in% cluster_samples))


mat_df <- pivot_wider(global_data, names_from = Barcode.ID, 
                   values_from = LogRatio) %>%
  as.data.frame() 
rownames(mat_df) <- mat_df$Gene

data_mat_train_all <- mat_df[, -1] %>% as.matrix()

mat_test_df <- pivot_wider(global_data_test, names_from = Barcode.ID, 
                           values_from = LogRatio) %>%
  as.data.frame() 
rownames(mat_test_df) <- mat_df$Gene
data_mat_test_all <- mat_test_df[, -1] %>% as.matrix()

complete_cases <- complete.cases(data_mat_train_all) & complete.cases(data_mat_test_all)
data_mat_train_all <- data_mat_train_all[complete_cases, ]
data_mat_test_all <- data_mat_test_all[complete_cases, ]

```




Setting up helper function for finding a statistically sound combination of $\alpha$
and $\lambda$ to build the model for cluster prediction on. 


```{r}

train_model <- function(chosen_cluster, chosen_alpha, random_state, diff_markers){
  cluster_lab <- paste("Cluster", chosen_cluster)
  
  data_mat <- data_mat_train_all
  data_mat_test <- data_mat_test_all
  if (diff_markers){
    cluster_markers <- diff_markers_k5 %>% 
      filter(Cluster == chosen_cluster) %>%
      filter(data_type == "Global") %>%
      filter(significance < 0.05) %>%
      filter(feature %in% rownames(data_mat_train_all)) %>%
      pull(feature)
    
    data_mat <- data_mat[cluster_markers, ]
    data_mat_test <- data_mat_test[cluster_markers, ]
  }
  

  cluster_bool <- cluster_assignments %>%
    mutate(cluster_bool = case_when(k.5 == chosen_cluster ~ cluster_lab,
                                    TRUE ~ paste("Not", cluster_lab))) %>%
    pull(cluster_bool) %>%
    as.factor()
  
  names(cluster_bool) <- cluster_assignments$Barcode.ID
  cluster_bool <- cluster_bool[colnames(data_mat_train_all)]
  
  meta_c <- left_join(meta, cluster_assignments, by = "Barcode.ID") %>%
    mutate(overallSurvival = as.numeric(overallSurvival),
           k.5 = as.character(k.5))
  rownames(meta_c) <- meta_c$Barcode.ID
  
  meta_c_train <- meta_c %>%
    filter(!is.na(k.5)) %>%
    mutate(Cluster = case_when(k.5 == chosen_cluster ~ cluster_lab,
                               TRUE ~ paste("Not", cluster_lab))) %>%
    group_by(Cluster) %>%
    # mutate(weight = 1 - n()/159) %>%
    # ungroup(Cluster) %>%
    as.data.frame()
  
  rownames(meta_c_train) <- meta_c_train$Barcode.ID
  
  # weights <- meta_c_train[colnames(data_mat), "weight"]
  
  lambda_max <- 1.5
  ## Using an fixed lambda path. This is so that we can compare
  ## alpha values more appropriately. This makes a single lambda_path
  ## with an appropriate range for any alpha between 0 and 1. 
  lambda_path <- round(exp(seq(log(lambda_max), log(lambda_max*0.000005), 
                               length.out = 200)), digits = 10)
  # hist(log(lambda_path))
  
  set.seed(random_state)
  
  folds <- groupdata2::fold(meta_c_train, k = 5, cat_col = "Cluster") %>%
    select(Barcode.ID, Cluster, .folds) %>%
    as.data.frame()
  rownames(folds) <- folds$Barcode.ID
  folds <- folds[colnames(data_mat), ]
  
  fold_ids <- folds$.folds %>% as.numeric()
  
  model <- cv.glmnet(x = t(data_mat),
                     y = cluster_bool,
                     family = 'binomial',
                     type.measure = "class",
                     alpha = chosen_alpha,
                     foldid = fold_ids,
                     lambda = lambda_path)
  
  cross_validation_error <- data.frame(error = model$cvm, row.names = model$lambda)
  colnames(cross_validation_error) <- paste("alpha =", as.character(chosen_alpha))
  
  return(cross_validation_error)
}

```


Reproducible method to tune alpha and lambda. We use cross validation to find
the best performing alpha and lambda parameter. The folds used are balanced
for the class we are predicting, determined by the 'chosen_cluster' parameter.


```{r}
run_cv_grid <- function(chosen_cluster,
                        diff_markers,
                        n_trials = 20,
                        master_random_state = 117,
                        alpha_values = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)){
    
  set.seed(master_random_state)
  random_states <- sample(1:1000000, size = n_trials)
  
  all_cvm <- lapply(random_states, function(random_state){
    ## Running cv over the grid using the folds determined by random_state
    grid_results <- lapply(alpha_values, function(chosen_alpha){
      cvm_results <- train_model(chosen_cluster, chosen_alpha, 
                                 random_state, diff_markers)
    }) %>% do.call("cbind", .)
  })
  
  cvm_avg <- Reduce('+', all_cvm)/length(random_states)
  return(cvm_avg)
}

```



## Running over all clusters in K = 5.

Now we can run the above tool over all the clusters in $k = 5$, the question of
interest being how well can protein data recapture the clusters, which are
derived from a combined dataset which includes phospho data as well as RNA counts.


```{r eval=FALSE, include=FALSE}
cluster_5_results <- run_cv_grid(chosen_cluster = "5", diff_markers = TRUE)
cluster_4_results <- run_cv_grid(chosen_cluster = "4", diff_markers = TRUE)
cluster_3_results <- run_cv_grid(chosen_cluster = "3", diff_markers = TRUE)
cluster_2_results <- run_cv_grid(chosen_cluster = "2", diff_markers = TRUE)
cluster_1_results <- run_cv_grid(chosen_cluster = "1", diff_markers = TRUE)

cluster_5_results_v2 <- run_cv_grid(chosen_cluster = "5", diff_markers = FALSE)
cluster_4_results_v2 <- run_cv_grid(chosen_cluster = "4", diff_markers = FALSE)
cluster_3_results_v2 <- run_cv_grid(chosen_cluster = "3", diff_markers = FALSE)
cluster_2_results_v2 <- run_cv_grid(chosen_cluster = "2", diff_markers = FALSE)
cluster_1_results_v2 <- run_cv_grid(chosen_cluster = "1", diff_markers = FALSE)

all_results <- list("Cluster 5 diff markers" = cluster_5_results,
                    "Cluster 5 all data" = cluster_5_results_v2,
                    "Cluster 4 diff markers" = cluster_4_results,
                    "Cluster 4 all data" = cluster_4_results_v2,
                    "Cluster 3 diff markers" = cluster_3_results,
                    "Cluster 3 all data" = cluster_3_results_v2,
                    "Cluster 2 diff markers" = cluster_2_results,
                    "Cluster 2 all data" = cluster_2_results_v2,
                    "Cluster 1 diff markers" = cluster_1_results,
                    "Cluster 1 all data" = cluster_1_results_v2)
saveRDS(all_results, "./elastic_net_binomial_models/elastic_net_results_k_5.RDS")



```


Finding the appropriate lambda range.


```{r eval=FALSE, include=FALSE}
bound_mult <- 2.0
min_bounds_all <- lapply(c("1", "2", "3", "4", "5"), function(chosen_cluster){
  lambda_min <- lapply(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), function(chosen_alpha){
    data_mat <- data_mat_train_all
    cluster_lab <- paste("Cluster", chosen_cluster)
    
    cluster_bool <- cluster_assignments %>%
      dplyr::mutate(cluster_bool = case_when(k.5 == chosen_cluster ~ cluster_lab,
                                        TRUE ~ paste("Not", cluster_lab))) %>%
      pull(cluster_bool) %>%
      as.factor()
    
    names(cluster_bool) <- cluster_assignments$Barcode.ID
    cluster_bool <- cluster_bool[colnames(data_mat)]
    model <- glmnet(x = t(data_mat),
                    y = cluster_bool,
                    family = 'binomial',
                    alpha = chosen_alpha)
    min(model$lambda)
  }) %>% unlist()
}) %>% do.call("cbind", .) %>%
  as.data.frame()
min_bounds_all <- as.matrix(min_bounds_all)*bound_mult 

# min_bounds_all <- apply(min_bounds_all, 1, function(yy){
#   rep(max(yy), 5)
# }) %>% t()
  
colnames(min_bounds_all) <- as.character(1:5)
rownames(min_bounds_all) <- as.character(1:10/10)

max_bounds_all <- lapply(c("1", "2", "3", "4", "5"), function(chosen_cluster){
  lambda_max <- lapply(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), function(chosen_alpha){
    data_mat <- data_mat_train_all
    cluster_lab <- paste("Cluster", chosen_cluster)
    
    cluster_bool <- cluster_assignments %>%
      dplyr::mutate(cluster_bool = case_when(k.5 == chosen_cluster ~ cluster_lab,
                                        TRUE ~ paste("Not", cluster_lab))) %>%
      pull(cluster_bool) %>%
      as.factor()
    
    names(cluster_bool) <- cluster_assignments$Barcode.ID
    cluster_bool <- cluster_bool[colnames(data_mat)]
    model <- glmnet(x = t(data_mat),
                    y = cluster_bool,
                    family = 'binomial',
                    alpha = chosen_alpha)
    max(model$lambda)
  }) %>% unlist()
}) %>% do.call("cbind", .) %>%
  as.data.frame()
max_bounds_all <- as.matrix(max_bounds_all)*bound_mult 

# max_bounds_all <- apply(max_bounds_all, 1, function(yy){
#   rep(max(yy), 5)
# }) %>% t()

colnames(max_bounds_all) <- as.character(1:5)
rownames(max_bounds_all) <- as.character(1:10/10)


```


Doing the same, but now for the parallel analysis using the differential markers.


```{r eval=FALSE, include=FALSE}

min_bounds_mark <- lapply(c("1", "2", "3", "4", "5"), function(chosen_cluster){
  lambda_min <- lapply(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), function(chosen_alpha){
    data_mat <- data_mat_train_all
    cluster_lab <- paste("Cluster", chosen_cluster)
    cluster_markers <- diff_markers_k5 %>% 
      dplyr::filter(Cluster == chosen_cluster) %>%
      dplyr::filter(data_type == "Global") %>%
      dplyr::filter(significance < 0.05) %>%
      dplyr::filter(feature %in% rownames(data_mat_train_all)) %>%
      pull(feature)
    
    data_mat <- data_mat[cluster_markers, ]
    
    cluster_bool <- cluster_assignments %>%
      dplyr::mutate(cluster_bool = case_when(k.5 == chosen_cluster ~ cluster_lab,
                                        TRUE ~ paste("Not", cluster_lab))) %>%
      pull(cluster_bool) %>%
      as.factor()
    
    names(cluster_bool) <- cluster_assignments$Barcode.ID
    cluster_bool <- cluster_bool[colnames(data_mat)]
    model <- glmnet(x = t(data_mat),
                    y = cluster_bool,
                    family = 'binomial',
                    alpha = chosen_alpha)
    min(model$lambda)
  }) %>% unlist()
}) %>% do.call("cbind", .) %>%
  as.data.frame()
min_bounds_mark <- as.matrix(min_bounds_mark)*bound_mult 

colnames(min_bounds_mark) <- as.character(1:5)
rownames(min_bounds_mark) <- as.character(1:10/10)

max_bounds_mark <- lapply(c("1", "2", "3", "4", "5"), function(chosen_cluster){
  lambda_max <- lapply(c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0), function(chosen_alpha){
    data_mat <- data_mat_train_all
    cluster_lab <- paste("Cluster", chosen_cluster)
    cluster_markers <- diff_markers_k5 %>% 
      dplyr::filter(Cluster == chosen_cluster) %>%
      dplyr::filter(data_type == "Global") %>%
      dplyr::filter(significance < 0.05) %>%
      dplyr::filter(feature %in% rownames(data_mat_train_all)) %>%
      pull(feature)
    
    data_mat <- data_mat[cluster_markers, ]
    
    cluster_bool <- cluster_assignments %>%
      dplyr::mutate(cluster_bool = case_when(k.5 == chosen_cluster ~ cluster_lab,
                                        TRUE ~ paste("Not", cluster_lab))) %>%
      pull(cluster_bool) %>%
      as.factor()
    
    names(cluster_bool) <- cluster_assignments$Barcode.ID
    cluster_bool <- cluster_bool[colnames(data_mat)]
    model <- glmnet(x = t(data_mat),
                    y = cluster_bool,
                    family = 'binomial',
                    alpha = chosen_alpha)
    max(model$lambda)
  }) %>% unlist()
}) %>% do.call("cbind", .) %>%
  as.data.frame()
max_bounds_mark <- as.matrix(max_bounds_mark)*bound_mult 

colnames(max_bounds_mark) <- as.character(1:5)
rownames(max_bounds_mark) <- as.character(1:10/10)


```


```{r eval=FALSE, include=FALSE}
bounds <- list("min_bounds_all" = min_bounds_all,
               "max_bounds_all" = max_bounds_all,
               "min_bounds_mark" = min_bounds_mark,
               "max_bounds_mark" = max_bounds_mark,
               "bound_mult" = bound_mult)
saveRDS(bounds, "./elastic_net_binomial_models/bounds.RDS")

```


```{r}
all_results <- readRDS("elastic_net_binomial_models/elastic_net_results_k_5.RDS")
bounds <- readRDS("elastic_net_binomial_models/bounds.RDS")
bounds <- readRDS("elastic_net_binomial_models/bounds.RDS")
min_bounds_all <- bounds$min_bounds_all
max_bounds_all <- bounds$max_bounds_all
min_bounds_mark <- bounds$min_bounds_mark
max_bounds_mark <- bounds$max_bounds_mark
bound_mult <- bounds$bound_mult

```




Plotting errors by cluster



```{r}
chosen_alpha <- 0.1
diff_markers <- FALSE
best_result <- function(chosen_cluster, chosen_alpha, diff_markers){
  result_name <- paste0("Cluster ", chosen_cluster)
  if (diff_markers){
    result_name <- paste0(result_name, " diff markers")
    xx <- all_results[[result_name]]
    max_lambda <- max_bounds_mark[chosen_alpha, chosen_cluster]
    min_lambda <- min_bounds_mark[chosen_alpha, chosen_cluster]
  } else {
    result_name <- paste0(result_name, " all data")
    xx <- all_results[[result_name]]
    max_lambda <- max_bounds_all[as.character(chosen_alpha), chosen_cluster]
    min_lambda <- min_bounds_all[as.character(chosen_alpha), chosen_cluster]
  }
  allowed_lambda <- as.numeric(rownames(xx)) > min_lambda
  allowed_lambda <- allowed_lambda & (as.numeric(rownames(xx)) < max_lambda)
  cvm <- min(xx[allowed_lambda, paste("alpha =", chosen_alpha)])
  return(cvm)
}

best_error <- lapply(c("1", "2", "3", "4", "5"), best_result, 
                     chosen_alpha, diff_markers) %>% unlist()

summary <- data.frame(Cluster = c("1", "2", "3", "4", "5"), 
                      `Best prediction error` = best_error)
plot_df <- summary

ggplot(plot_df, aes(x = Cluster, y = Best.prediction.error)) + 
  geom_bar(stat = 'identity', width = 0.27, fill = "dodgerblue4") + theme_minimal() +
  ggtitle("Elastic Net best prediction results") + xlab("Cluster")
ggsave(paste0("elastic_net_binomial_models/prediction_errors_enet_binomial_", chosen_alpha, ".pdf"))


```


